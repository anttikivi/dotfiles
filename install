#!/bin/bash

set -e

source ./utils/colors.sh

declare -a SUPPORTED_PLATFORMS=("darwin" "debian")
readonly SUPPORTED_PLATFORMS

declare -a FULL_PIP_PACKAGES=("ansible")
readonly FULL_PIP_PACKAGES
declare -a PIP_PACKAGES=("ansible-lint")
readonly PIP_PACKAGES
declare -a DARWIN_PACKAGES=(
  "clang-format"
  "cormacrelf/tap/dark-notify"
  "gh"
  "fzf"
  "jq"
  "lima"
  "opentofu"
  "php"
  "reattach-to-user-namespace"
  "ripgrep"
  "roots/tap/trellis-cli"
  "shellcheck"
  "tmux"
  "wget"
)
readonly DARWIN_PACKAGES
declare -a DARWIN_CASKS=("nikitabobko/tap/aerospace")
readonly DARWIN_CASKS

OS_NAME="$(uname | tr '[:upper:]' '[:lower:]')"
if [ "$(uname)" = "Linux" ]; then
  distro="$(cat /etc/*-release | grep ^ID | head -n1 | cut -d '=' -f2)"
  if [ "${distro}" = "debian" ] || [ "${distro}" = "ubuntu" ]; then
    OS_NAME="debian"
  fi
fi
readonly OS_NAME
export OS_NAME

HAS_CONNECTION=false
if ping -q -c1 8.8.8.8 &>/dev/null; then
  HAS_CONNECTION=true
fi
readonly HAS_CONNECTION
export HAS_CONNECTION

function not_supported() {
  echo "This system is not supported: $*" >&2
  exit 1
}

function print_help() {
  echo "help"
  exit 0
}

function print_version() {
  echo "version"
  exit 0
}

if [[ ! " ${SUPPORTED_PLATFORMS[*]} " =~ [[:space:]]${OS_NAME}[[:space:]] ]]; then
  not_supported "${OS_NAME}"
fi

readonly call_args=("$@")

QUIET=0
VERBOSE=0

OPTIND=1
while getopts "hqQvV" opt; do
  case "${opt}" in
    h)
      print_help
      ;;
    q)
      ((quiet++))
      ;;
    Q)
      QUIET=$((QUIET + 2))
      ;;
    v)
      ((verbose++))
      ;;
    V)
      print_version
      ;;
    *)
      echo "Unexpected option: ${opt}"
      exit 1
      ;;
  esac
done
shift "$((OPTIND - 1))"
set -- "${call_args[@]}"

export QUIET
export VERBOSE

if ((VERBOSE > 0)) && ((QUIET > 0)); then
  echo -e "${ESC_RED}You want the script to be both verbose and quiet...${ESC_RESET}"
  exit 1
fi

# Printing the verbosity level when it's only one might be too verbose.
if ((VERBOSE > 1)); then echo -e "${ESC_YELLOW}The verbosity of the script is currently set to ${VERBOSE}${ESC_RESET}"; fi

if [ "${HAS_CONNECTION}" = "true" ]; then
  if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}The script can use an Internet connection${ESC_RESET}"; fi
elif ((QUIET > 1)); then
  echo -e "${ESC_YELLOW}Running the script without an Internet connection${ESC_RESET}"
fi

if [ "${DO_UPDATES}" = "true" ] && [ "${HAS_CONNECTION}" = "true" ] && ((VERBOSE > 0)); then
  echo -e "${ESC_YELLOW}Installing updates if they are available${ESC_RESET}\n"
fi

if [ "${OS_NAME}" = "darwin" ] && ! command -v brew >/dev/null 2>&1; then
  if [ "${HAS_CONNECTION}" = "true" ]; then
    if ((VERBOSE > 0)); then echo -e "\n${ESC_BLUE}Installing Homebrew${ESC_RESET}"; fi
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    eval "$(/opt/homebrew/bin/brew shellenv)"
    if ((QUIET < 2)); then echo -e "${ESC_GREEN}Homebrew installed${ESC_RESET}"; fi
  else
    echo "Homebrew is not installed and there is not Internet connection, exiting..." >&2
    exit 1
  fi
fi

if [ "${HAS_CONNECTION}" = "true" ]; then
  if [ "${OS_NAME}" = "darwin" ]; then
    # shellcheck disable=SC2046
    brew update $( ((QUIET > 0)) && printf %s '-q') $( ((VERBOSE > 0)) && printf %s '-v')
    if [ "${UPGRADE_PACKAGES}" = "true" ]; then
      # shellcheck disable=SC2046
      brew upgrade $( ((QUIET > 0)) && printf %s '-q') $( ((VERBOSE > 0)) && printf %s '-v')
    fi
  elif [ "${OS_NAME}" = "debian" ]; then
    echo -e "${ESC_RED}Updating the packages on '${OS_NAME}' is not implemented yet${ESC_RESET}"
    not_supported "${OS_NAME}"
  fi
fi

if ! command -v python >/dev/null 2>&1; then
  if [ "${HAS_CONNECTION}" = "true" ]; then
    if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}Installing Python${ESC_RESET}"; fi
    if [ "${OS_NAME}" = "darwin" ]; then
      # shellcheck disable=SC2046
      brew install python $( ((QUIET > 0)) && printf %s '-q') $( ((VERBOSE > 0)) && printf %s '-v')
      PATH="$(brew --prefix python)/libexec/bin:${PATH}"
      export PATH
      PYTHONPATH="$(brew --prefix)/lib/python$(python --version | awk '{print $2}' | cut -d '.' -f 1,2)/site-packages"
      export PYTHONPATH
    elif [ "${OS_NAME}" = "debian" ]; then
      echo -e "${ESC_RED}Installing Python on '${OS_NAME}' is not implemented yet${ESC_RESET}"
      not_supported "${OS_NAME}"
    fi
    if ((QUIET < 2)); then echo -e "${ESC_GREEN}Python installed${ESC_RESET}"; fi
  else
    echo "Python is not installed and there is not Internet connection, exiting..." >&2
    exit 1
  fi
fi

if ! command -v pipx >/dev/null 2>&1; then
  if [ "${HAS_CONNECTION}" = "true" ]; then
    if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}Installing pipx${ESC_RESET}"; fi
    if [ "${OS_NAME}" = "darwin" ]; then
      # shellcheck disable=SC2046
      brew install pipx $( ((QUIET > 0)) && printf %s '-q') $( ((VERBOSE > 0)) && printf %s '-v')
      PATH="${HOME}/.local/bin:${PATH}"
      export PATH
    elif [ "${OS_NAME}" = "debian" ]; then
      echo -e "${ESC_RED}Installing pipx on '${OS_NAME}' is not implemented yet${ESC_RESET}"
      not_supported "${OS_NAME}"
    fi
    if ((QUIET < 2)); then echo -e "${ESC_GREEN}pipx installed${ESC_RESET}"; fi
  else
    echo "pipx is not installed and there is not Internet connection, exiting..." >&2
    exit 1
  fi
fi

if ((QUIET < 2)); then echo -e "\n${ESC_GREEN}==> All prerequisites are set up${ESC_RESET}"; fi

CONFIG="install.conf.yaml"
DOTBOT_DIR="dotbot"

DOTBOT_BIN="bin/dotbot"
BASEDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

cd "${BASEDIR}"
git -C "${DOTBOT_DIR}" submodule sync --quiet --recursive
git submodule update --init --recursive "${DOTBOT_DIR}"

"${BASEDIR}/${DOTBOT_DIR}/${DOTBOT_BIN}" -d "${BASEDIR}" -c "${CONFIG}" "${@}"

if [ "$(basename "${SHELL}")" = "zsh" ]; then
  if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}Sourcing the shell environment${ESC_RESET}"; fi
  # shellcheck source=../../.bash_profile
  source "${HOME}/.bash_profile"
  if ((QUIET < 2)); then echo -e "${ESC_GREEN}==> Shell environment sourced${ESC_RESET}"; fi
fi

if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}Installing the tools and utilities using package managers${ESC_RESET}"; fi
for pkg in "${FULL_PIP_PACKAGES[@]}"; do
  pipx install --include-deps "${pkg}"
done
for pkg in "${PIP_PACKAGES[@]}"; do
  pipx install "${pkg}"
done
if [ "${OS_NAME}" = "darwin" ]; then
  brew install "${DARWIN_PACKAGES[@]}"
  for cask in "${DARWIN_CASKS[@]}"; do
    brew install --cask "${cask}"
  done
elif [ "${OS_NAME}" = "debian" ]; then
  echo -e "${ESC_RED}Installing packages on '${OS_NAME}' is not implemented yet${ESC_RESET}"
  not_supported "${OS_NAME}"
fi
if ((QUIET < 2)); then echo -e "\n${ESC_GREEN}==> Tools and utilities installed${ESC_RESET}"; fi

if ((QUIET < 1)); then echo -e "${ESC_BLUE}Running the tasks from scripts${ESC_RESET}"; fi
for script in "${BASEDIR}"/installs/*; do
  cd "$(dirname "${script}")"
  if ((VERBOSE > 0)); then echo -e "${ESC_BLUE}Running the '$(basename "${script}")' tasks${ESC_RESET}"; fi
  /bin/sh "${script}"
  if ((VERBOSE > 0)); then echo -e "${ESC_GREEN}'$(basename "${script}")' tasks run${ESC_RESET}"; fi
  cd - >/dev/null
done
if ((QUIET < 1)); then echo -e "\n${ESC_GREEN}==> All tasks run${ESC_RESET}"; fi
